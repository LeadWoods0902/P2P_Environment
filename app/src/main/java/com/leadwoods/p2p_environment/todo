1. Set "I am a group owner"
2. Only display group owners in recycler view
    2a. Add a toggle in the menu
3. Player send data to GM (peer -> GO)
4. GM send data to all players (GO -> peer in peers)
5. Send JSON objects across the network


package com.leadwoods.p2p_environment

import android.Manifest
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.net.wifi.WifiManager
import android.net.wifi.p2p.WifiP2pConfig
import android.net.wifi.p2p.WifiP2pConfig.GROUP_OWNER_INTENT_MAX
import android.net.wifi.p2p.WifiP2pConfig.GROUP_OWNER_INTENT_MIN
import android.net.wifi.p2p.WifiP2pDevice
import android.net.wifi.p2p.WifiP2pDeviceList
import android.net.wifi.p2p.WifiP2pInfo
import android.net.wifi.p2p.WifiP2pManager
import android.net.wifi.p2p.WifiP2pManager.ActionListener
import android.net.wifi.p2p.WifiP2pManager.BUSY
import android.net.wifi.p2p.WifiP2pManager.Channel
import android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener
import android.net.wifi.p2p.WifiP2pManager.ERROR
import android.net.wifi.p2p.WifiP2pManager.NO_SERVICE_REQUESTS
import android.net.wifi.p2p.WifiP2pManager.P2P_UNSUPPORTED
import android.os.Build
import android.os.Bundle
import android.view.Menu
import android.view.MenuItem
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.leadwoods.p2p_environment.support.AppBase
import com.leadwoods.p2p_environment.support.Logger
import com.leadwoods.p2p_environment.support.checkAllPermissions
import com.leadwoods.p2p_environment.support.permissionsOverview
import com.leadwoods.p2p_environment.support.requestAllPermissions
import kotlin.math.min


/**
 * Main Activity
 * @property peersRV RecyclerView for displaying instances of [WifiP2pDevice]
 * @property sendDataB Button for broadcasting as a hot
 * @property scanB Button for searching scan for hosts
 * @property isP2PEnabled Boolean flag
 * @property p2pIntentFilter
 * @property p2pManager
 * @property p2pChannel
 * @property p2pReceiver
 */
class MainActivity: AppBase(), PeersAdapter.PeerTouchInterface, ConnectionInfoListener {


    companion object {
        const val PERMISSION_REQUEST_CODE = 902
    }



    // Game Control Flags
    private var isGameMaster: Boolean = false
    private var isGroupOwner: Boolean = false


    // UI elements
    private lateinit var peersRV: RecyclerView
    private lateinit var becomeHostB: Button
    private lateinit var scanB: Button
    private lateinit var sendDataB: Button

    private lateinit var userTypeTV: TextView
    private lateinit var transmitET: EditText
    private lateinit var receivedTV: TextView

    private lateinit var hostInfo: WifiP2pInfo


    // p2p flags
    private var isP2PEnabled: Boolean = false
    private var keepDownloading: Boolean = true
    private val showAllPeers: Boolean = true

    // p2p networking elements
    val p2pIntentFilter = IntentFilter().apply {
        addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)
        addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)
        addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)
        addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)
    }

    var p2pManager: WifiP2pManager? = null
    var p2pChannel: Channel? = null
    var p2pReceiver: BroadcastReceiver? = null


    /**
     * callback from P2PConnectionsListener, sets p2p enabled status
     * @param enabled passed value for enabled status
     */
    fun p2pEnabled(enabled: Boolean){
        Logger.d("called | P2P: ${if(enabled) "Enabled" else "Not Available"}")
        isP2PEnabled = enabled
    }


    /**
     * callback from permission request dialogs
     * @param requestCode
     * @param permissions
     * @param grantResults
     */
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        when(requestCode){
            PERMISSION_REQUEST_CODE -> {
                for (permission in grantResults) {
                    if (permission != PackageManager.PERMISSION_GRANTED) {
                        Logger.w("Permission Not Granted (${permission.toString().split(".").last()})")
                        finish()
                    }
                }
            }
            else -> {
                Logger.w("Unexpected Permission Request Code")
            }
        }
    }


    /**
     * Check & request any missing permissions
     * @param toast Boolean flag indicating whether the user should be notified of the permission results
     */
    private fun checkAndRequestPermissions(toast: Boolean) {

        // Request Location if Not Granted
        if(!checkAllPermissions())
        {
            requestAllPermissions(this, supportFragmentManager)
        }

        // Display results if necessary
        if(toast) {
            val overview = permissionsOverview()
            Toast.makeText(this, "${overview.second}/${overview.third}", Toast.LENGTH_SHORT).show()
            Logger.d(overview.first)
        }
    }


    /**
     *
     */
    private fun initP2p(): Boolean {

        // Compatibility check
        if(!packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT)) {
            Logger.e("Wi-Fi Direct is not supported by this device")
            return false
        }

        // Hardware check
        if(getSystemService(Context.WIFI_SERVICE) == null){
            Logger.e("Cannot get Wi-Fi system service.")
            return false
        }

        // Availability check
        if (!(getSystemService(Context.WIFI_SERVICE) as WifiManager).isP2pSupported) {
            Logger.e("Wi-Fi Direct is not supported by the hardware or Wi-Fi is off.")
            return false
        }

        // Create
        p2pManager = (getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager)
        if(p2pManager == null){
            Logger.e("Cannot get Wi-Fi Direct system service.")
            return false
        }

        p2pChannel = p2pManager!!.initialize(this, mainLooper, null)
        if(p2pChannel == null){
            Logger.e("Cannot initialize Wi-Fi Direct.")
            return false
        }

        return true
    }


    /**
     * Creates the activity, calls for permission checks, sets up broadcasting & configures interface
     * @param savedInstanceState
     */
    override fun onCreate(savedInstanceState: Bundle?) {
        Logger.d("called")
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Attempt to Initialise P2P
        if (!initP2p()) {
            // Toast Error if P2P not available
            Logger.e("ERROR in P2P init")
            finish()
        }

        // P2P is available, so check permissions
        checkAndRequestPermissions(false)

        // Configure Interface
        configInterface()
    }

    /**
     * Configures the User Interface
     */
    private fun configInterface() {
        // Get UI Elements
        peersRV = findViewById(R.id.RV_Peers)
        becomeHostB = findViewById(R.id.B_BecomeHost)
        sendDataB = findViewById(R.id.B_Broadcast)
        scanB = findViewById(R.id.B_Scan)

        userTypeTV = findViewById(R.id.TV_UserType)
        receivedTV = findViewById(R.id.TV_ReceivedData)
        transmitET = findViewById(R.id.ET_TransmitData)

        peersRV.layoutManager = LinearLayoutManager(this).apply {
            orientation = LinearLayoutManager.VERTICAL
        }

        sendDataB.setOnClickListener {
            Logger.d("${resources.getResourceEntryName(it.id)} clicked")

            val data = transmitET.text.toString()
            Logger.d("Transmitting: ${data.subSequence(0, min(data.length, 20))}")

            startService(Intent(this, DataTransferService::class.java).apply {
                action = ACTION_SEND_JSON
                putExtra(RAW_DATA, data)
                putExtra(GO_ADDRESS, hostInfo.groupOwnerAddress.hostAddress)
                putExtra(GO_PORT, 8988)
            })
        }

        scanB.setOnClickListener {
            Logger.d("${resources.getResourceEntryName(it.id)} clicked")

            // Clear existing Peers
            clearPeerResults()

            // Make device visible to p2p
            if(isGameMaster)
                createGroup()
            else
                enableDiscovery()
        }

        becomeHostB.setOnClickListener {
            Logger.d("${resources.getResourceEntryName(it.id)} clicked")

            isGameMaster = !isGameMaster

            (it as Button).text = if(isGameMaster) "Status: Host" else "Status: Client"

            scanB.text = if(isGameMaster) "Host Lobby" else "Scan for Lobbies"
        }
    }


    /**
     * Clear the peers recycler view
     */
    fun clearPeerResults() {
        peersRV.adapter = PeersAdapter(listOf(), this)
    }


    /**
     * When resuming the the activity, create a new listener if neccesary then register it
     */
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    override fun onResume() {
        Logger.d("called")
        super.onResume()

        if (p2pReceiver == null){
            Logger.d("p2pReceiver was null")
            if(p2pManager != null && p2pChannel != null)
                p2pReceiver = P2PConnectionsListener(p2pManager!!, p2pChannel!!, this)
        }
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            registerReceiver(p2pReceiver, p2pIntentFilter, RECEIVER_NOT_EXPORTED)
        else
            registerReceiver(p2pReceiver, p2pIntentFilter)


    }

    /**
     * When pausing the the activity, unregister the receiver if it still exists
     */
    override fun onPause() {
        Logger.d("called")
        super.onPause()
        p2pReceiver?.also { p2pReceiver ->
            unregisterReceiver(p2pReceiver)
        }
    }


    /**
     *  Inflate the options menu, disable the NearbyDevice's prompt if not on at least Tiramisu
     *  @param menu the [Menu] object to inflate a view inside
     */
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        Logger.d("called")
        menuInflater.inflate(R.menu.menu_primary, menu)

        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
            menu?.findItem(R.id.MI_NearbyDevices)?.setVisible(false)
        }

        return super.onCreateOptionsMenu(menu)
    }


    @SuppressLint("UseSwitchCompatOrMaterialCode")
    /**
     * @param item The [MenuItem] that was selected by the user
     * @return always true as all outcomes finish handling the user's input
     */
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        Logger.d("called")
        when(item.itemId){
            R.id.MI_RequestPermissions -> {
                checkAndRequestPermissions(true)
            }

            R.id.MI_NearbyDevices -> {
                if(ContextCompat.checkSelfPermission(this, Manifest.permission.NEARBY_WIFI_DEVICES) == PackageManager.PERMISSION_GRANTED)
                    Toast.makeText(this, "Permission Granted", Toast.LENGTH_SHORT).show()
                else
                    Toast.makeText(this, "Permission Not Granted", Toast.LENGTH_SHORT).show()
            }

            R.id.MI_Disconnect -> {
                if(!isGroupOwner) {
                    disconnect()
                    return true
                }
            }

            else -> {
                throw Exception("Unexpected Menu Selection")
            }
        }

        return true
    }




    @SuppressLint("MissingPermission")
    /**
     *
     */
    private fun enableDiscovery() {
        Logger.d("called")

        // Enable Peer Discovery
        p2pManager?.discoverPeers(p2pChannel, object : ActionListener {
            override fun onSuccess() {
                Toast.makeText(this@MainActivity, "Discovery Launched Successfully", Toast.LENGTH_SHORT).show()
            }

            override fun onFailure(reason: Int) {
                Toast.makeText(this@MainActivity, "Discovery Error", Toast.LENGTH_SHORT).show()
                if(listOf(ERROR, P2P_UNSUPPORTED, BUSY, NO_SERVICE_REQUESTS).contains(reason))
                    Logger.w("p2p failed | $reason")
                else
                    Logger.e("Unknown p2p error | $reason")
            }
        })

    }


    /**
     * callback from p2pListener with list of found peers
     * @param peers instance of [WifiP2pDeviceList] containing nearby peers
     */
    fun onPeersAvailable(devices: WifiP2pDeviceList) {
        Logger.d("called")
        val peers = deviceListToListPeers(devices)
        if(showAllPeers) {
            // Show all available peers
            peersRV.adapter = PeersAdapter(peers, this)
        } else {
            // Only show peers that are group owners
            peersRV.adapter = PeersAdapter(tagPeersOwnerStatus(peers), this)
        }
    }

    /**
     * callback from [PeersAdapter] indicating a user wants to connect to a peer
     * @param peer Instance of [WifiP2pDevice] deonating a nearby device
     */
    override fun selectPeer(peer: WifiP2pDevice) {
        Logger.d("called | Connecting To: ${peer.deviceName}")
        Toast.makeText(this, "Connecting To: ${peer.deviceName}", Toast.LENGTH_SHORT).show()

        connect(peer)
    }

    @SuppressLint("MissingPermission")
    /**
     * Attempt to connect to the given peer
     * @param peer The device to attempt a connection with
     */
    fun connect(peer: WifiP2pDevice){
        Logger.d("called")

        val config = WifiP2pConfig().apply {
            deviceAddress = peer.deviceAddress
            groupOwnerIntent = if(isGameMaster) GROUP_OWNER_INTENT_MAX else GROUP_OWNER_INTENT_MIN
        }

        p2pChannel?.also { channel ->
            p2pManager?.connect(channel, config, object : ActionListener {


                /**
                 * Connection request sent successfully
                 */
                override fun onSuccess() {
                    Logger.d("Connection Request Sent to ${peer.deviceName}")
                    Toast.makeText(this@MainActivity, "Connection Request Sent", Toast.LENGTH_SHORT).show()
                }


                /**
                 * Connection request failed to send
                 */
                override fun onFailure(reason: Int) {
                    Logger.w("Connection to ${peer.deviceName} Failed")
                    Toast.makeText(this@MainActivity, "Connection Failed", Toast.LENGTH_SHORT).show()
                }
            })
        }
    }


    /**
     * Disconnect from the current group
     */
    private fun disconnect() {
        Logger.d("called")

        p2pChannel?.also { channel ->
            p2pManager?.removeGroup(channel, object : ActionListener {
                override fun onSuccess() {
                    Logger.d("disconnected from group")
                }

                override fun onFailure(reason: Int) {
                    Logger.e("Disconnect failed. Reason : $reason")
                }
            })
        }
    }

    /**
     * Connection info about the current group available
     * @param info Information to be displayed
     */
    override fun onConnectionInfoAvailable(info: WifiP2pInfo?) {
        Logger.d("called | $info")
        if (info != null) {
            Logger.d("Connected to ${info.groupOwnerAddress}")
            hostInfo = info

            // Update the UI to reflect the device's user type
            if(info.groupFormed) {
                DataListener(this).execute()

                isGroupOwner = if (info.isGroupOwner) {
                    userTypeTV.text = "Hosting"
                    true
                } else {
                    userTypeTV.text = "Connected to: ${info.groupOwnerAddress}"
                    false
                }
            }
        }
    }

    /**
     *
     */
    fun downloadComplete(received: String) {

        receivedTV.text = received

        if(keepDownloading)
            DataListener(this).execute()
    }

    @SuppressLint("MissingPermission")
    fun createGroup() {
        p2pChannel?.also { channel ->
            p2pManager?.createGroup(channel, object: ActionListener{
                override fun onSuccess() {
                    Logger.d("Group Creation successful")
                }

                override fun onFailure(reason: Int) {
                    Logger.e("Failed to create group: $reason")
                }
            })
        }
    }

}